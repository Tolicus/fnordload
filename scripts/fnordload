#!/usr/bin/env python

import fnordload
import time
import signal
import sys
import logging
import logging.handlers
import max7301
import nupay

class Fnordload(object):
    def __init__(self, LCDserver = 'localhost', eSSPport = '/dev/ttyACM0',
            inhibits = [0, 0, 0, 0, 0, 0, 0, 0], cointype = 0.5):
        self._logger = logging.getLogger('logger')
        self._lcd = fnordload.LCD(LCDserver)
        self._io_device = max7301.MAX7301()
        self._keypad = fnordload.KeyPad(self._io_device)
        self._note_validator = fnordload.NoteValidator(
                device = eSSPport, inhibits = inhibits)
        self._coin_hopper = fnordload.CoinHopper(cointype, io_device = self._io_device)
        self._ui = fnordload.UI(keypad = self._keypad, lcd = self._lcd)
        self._setup()

    def _setup(self):
        self._lcd.setup()

    def main(self):
        main_menu = (
            {'key': 1, 'name': "Give Change",  'function': self._give_change,   'visible': True},
            {'key': 2, 'name': "UPAY",         'function': self._upay_menu,     'visible': True},
            {'key': 3, 'name': "Manage",       'function': self._manage,        'visible': True},
        )
        while True:
            try:
                self._ui.choose("Fnordload Main Menu", main_menu)
            except fnordload.TimeoutError:
                pass

    def _manage(self):
        self._lcd.write("Fnordload MGT  Menu", "", "Enter Code", "             The MGT")
        code = (1,1,1,1,1)
        input = []

        while True:
            k = self._keypad.get_single_key()
            if k != '#':
                input.append(k)
            else:
                if list(code) == input:
                    self._manage_menu()
                else:
                    self._lcd.write("Fnordload MGT  Menu", "", "Wrong Code", "             The MGT")
                    time.sleep(5)
                break

    def _manage_menu(self):
        manage_menu = (
            {'key': 1,      'name': "Load Coins",   'function': self._load_coins,       'visible': True},
            {'key': 2,      'name': "Empty Hopper", 'function': self._not_implemented,  'visible': True},
            {'key': '*',    'name': "Exit",         'function': lambda: None,           'visible': False},
        )

        self._ui.choose("Fnordload MGT Menu", manage_menu)

    def _upay_menu(self):
        upay_menu = (
            {'key': 1,      'name': "Show Balance",     'function': self._upay_show_balance,    'visible': True},
            {'key': 2,      'name': "Get Tokens",       'function': self._not_implemented,      'visible': True},
            {'key': 3,      'name': "Normalize Purse",  'function': self._not_implemented,      'visible': True},
            {'key': '*',    'name': "Exit",             'function': lambda: None,               'visible': False},
        )

        self._ui.choose("Fnordload UPAY Menu", upay_menu)

    def _not_implemented(self):
        self._lcd.write("Fnordload", "", "Not Yet Implemented", "             The MGT")
        time.sleep(5)

    def _load_coins(self):
        coins = 0
        while True:
            self._lcd.write("Fnordload MGT Menu", "Load Coins", "Amount: %d" % coins, "")
            k = self._keypad.get_single_key()
            if k == '#':
                break
            if k == '*':
                coins = coins / 10
            else:
                coins *= 10
                coins += k

        self._lcd.write("Fnordload MGT Menu", "Load Coins", "Amount: %d" % coins, "WRITING")
        self._coin_hopper.increase_coin_level(coins)
        self._lcd.write("Fnordload MGT Menu", "Load Coins", "Amount: %d" % coins, "DONE")
        time.sleep(2)
        self._lcd.write("Fnordload MGT Menu", "New Coin Level", "%d Coins" % self._coin_hopper.coin_level, "")
        time.sleep(2)

    def _upay_show_balance(self):
        token_reader = nupay.USBTokenReader()
        t0 = time.time()

        self._lcd.write("Fnordload UPAY", "Please insert", "USB drive with", "purse file(s)")

        tokens = []
        while time.time() < t0 + 30:
            try:
                tokens = token_reader.read_tokens(
                            found_medium_callback =
                                lambda: self._lcd.write("Fnordload UPAY", "", "Reading USB drive", ""))
                break
            except nupay.NoTokensAvailableError:
                time.sleep(1)

        if not tokens:
            self._lcd.write("Fnordload UPAY", "", "No valid purse found", "")
            time.sleep(5)
            return

        token_client = nupay.TokenClient()
        tokens = token_client.validate_tokens(tokens)
        value = sum([token.value for token in tokens])

        self._lcd.write("Fnordload UPAY", "", "Read %d tokens" % len(tokens), "Value: %.2f Euro" % value)
        time.sleep(5)

    def _give_change(self):
        self._note_validator.set_max_accepted_value(
                self._coin_hopper.coin_level *
                self._coin_hopper.coin_type)

        accepted_values = self._note_validator.get_accepted_values()
        self._lcd.show_accepted_values(accepted_values)

        if not accepted_values:
            time.sleep(5)
            return

        try:
            amount = self._note_validator.read_note()
            self._coin_hopper.payout(amount)
        except fnordload.InvalidNoteError:
            self._lcd.rejected_note()
            time.sleep(2)
        except fnordload.TimeoutError:
            pass

    def exit_handler(self, signal, frame):
        self._coin_hopper.reset()
        self._note_validator.exit()

        sys.exit(0)

if __name__ == "__main__":
    logger = logging.getLogger('logger')
    logger.setLevel(logging.INFO)

    logger_host = "83.133.178.69"
    logger_port = 2325

    handler = logging.handlers.SysLogHandler(address = (logger_host, logger_port), facility=19)
    logger.addHandler(handler)

    logger.info('Starting fnordload')

    try:
        fl = Fnordload(inhibits = [1, 1, 1, 0, 0, 0])
        signal.signal(signal.SIGINT, fl.exit_handler)

        while True:
            fl.main()
    except Exception, e:
        logger.exception(e)
        import traceback
        traceback.print_exc()
        sys.exit(1)

    sys.exit(0)


